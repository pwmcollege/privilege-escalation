use futures::StreamExt;
use rustc_hash::FxBuildHasher;
use std::collections::HashSet;
use std::env;
use std::path::PathBuf;
use std::process;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::fs::{DirBuilder, File};
use tokio_tar::Archive;

async fn extract_tar(archive_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let unique_dir = format!("/challenge/safe_extract/task_{}_{}",
        SystemTime::now().duration_since(UNIX_EPOCH)?.as_nanos(),
        process::id()
    );
    
    DirBuilder::new()
        .recursive(true)
        .mode(0o700)
        .create(&unique_dir)
        .await?;

    println!("Extracting to: {}", unique_dir);

    let mut archive = Archive::new(File::open(archive_path).await?);
    let mut entries = archive.entries()?;
    let mut visited: HashSet<PathBuf, FxBuildHasher> = HashSet::default();
    
    while let Some(Ok(mut entry)) = entries.next().await {
        entry.set_allow_external_symlinks(false); // ⫘⫘⫘⫘  
        let _ = entry.unpack_in_raw(&unique_dir, &mut visited).await;
    }
    Ok(())
}

#[tokio::main]
async fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <archive.tar>", args[0].as_str());
        process::exit(1);
    }

    if let Err(_) = extract_tar(&args[1]).await {
        process::exit(1);
    }
}
